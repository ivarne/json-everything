<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JsonPath.Net</name>
    </assembly>
    <members>
        <member name="T:Json.Path.CountFunction">
            <summary>
            Implements the `count()` function which returns the number of nodes
            in a nodelist.
            </summary>
        </member>
        <member name="P:Json.Path.CountFunction.Name">
            <summary>
            Gets the function name.
            </summary>
        </member>
        <member name="M:Json.Path.CountFunction.Evaluate(Json.Path.NodeList)">
            <summary>
            Evaluates the function.
            </summary>
            <param name="nodeList">A nodelist</param>
            <returns>The number of nodes in the nodelist.</returns>
        </member>
        <member name="T:Json.Path.FilterSelector">
            <summary>
            Represents a filter expression selector.
            </summary>
        </member>
        <member name="P:Json.Path.FilterSelector.Expression">
            <summary>
            Gets the expression.
            </summary>
        </member>
        <member name="M:Json.Path.FilterSelector.Evaluate(Json.Path.Node,System.Text.Json.Nodes.JsonNode)">
             <summary>
             Evaluates the selector.
             </summary>
             <param name="match">The node to evaluate.</param>
             <param name="rootNode">The root node (typically used by filter selectors, e.g. `$[?@foo &lt; $.bar]`)</param>
             <returns>
             A collection of nodes.
            
             Semantically, this is a nodelist, but leaving as IEnumerable&lt;Node&gt; allows for deferred execution.
             </returns>
        </member>
        <member name="M:Json.Path.FilterSelector.BuildString(System.Text.StringBuilder)">
            <summary>
            Builds a string using a string builder.
            </summary>
            <param name="builder">The string builder.</param>
        </member>
        <member name="M:Json.Path.FilterSelector.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="T:Json.Path.FunctionRepository">
            <summary>
            Stores expression function definitions.
            </summary>
        </member>
        <member name="M:Json.Path.FunctionRepository.Register(Json.Path.ValueFunctionDefinition)">
            <summary>
            Registers a new function implementation, allowing it to be parsed.
            </summary>
            <param name="function">The function.</param>
        </member>
        <member name="M:Json.Path.FunctionRepository.Register(Json.Path.LogicalFunctionDefinition)">
            <summary>
            Registers a new function implementation, allowing it to be parsed.
            </summary>
            <param name="function">The function.</param>
        </member>
        <member name="M:Json.Path.FunctionRepository.Register(Json.Path.NodelistFunctionDefinition)">
            <summary>
            Registers a new function implementation, allowing it to be parsed.
            </summary>
            <param name="function">The function.</param>
        </member>
        <member name="M:Json.Path.FunctionRepository.Unregister``1">
            <summary>
            Unregisters a function implementation.
            </summary>
            <typeparam name="T">The type of function.</typeparam>
        </member>
        <member name="M:Json.Path.FunctionRepository.Unregister(System.String)">
            <summary>
            Unregisters a function implementation.
            </summary>
        </member>
        <member name="M:Json.Path.FunctionRepository.TryGet(System.String,Json.Path.IPathFunctionDefinition@)">
            <summary>
            Gets a function implementation by name.
            </summary>
            <param name="name">A function name.</param>
            <param name="function">The function, if found; otherwise null.</param>
            <returns>True if found; otherwise false.</returns>
        </member>
        <member name="T:Json.Path.FunctionType">
            <summary>
            Indicates the return type of a filter expression function.
            </summary>
        </member>
        <member name="F:Json.Path.FunctionType.Unspecified">
            <summary>
            Holder for a default value.  Not an actual valid function type.
            </summary>
        </member>
        <member name="F:Json.Path.FunctionType.Value">
            <summary>
            Indicates the function returns a JSON-like value that can be
            compared with equality and inequality operators.
            </summary>
        </member>
        <member name="F:Json.Path.FunctionType.Logical">
            <summary>
            Indicates the function returns a non-JSON boolean value that can be
            compared with logical operators.
            </summary>
        </member>
        <member name="F:Json.Path.FunctionType.Nodelist">
            <summary>
            Indicates the function returns a nodelist.
            </summary>
        </member>
        <member name="T:Json.Path.IFilterExpression">
            <summary>
            Exposes the filter expression.
            </summary>
        </member>
        <member name="M:Json.Path.IFilterExpression.Evaluate(System.Text.Json.Nodes.JsonNode,System.Text.Json.Nodes.JsonNode)">
            <summary>
            Evaluates the selector.
            </summary>
            <param name="globalParameter">The root node of the data, represented by `$`.</param>
            <param name="localParameter">The current node in the filter, represented by `@`.</param>
            <returns>
            true if the node should be selected; false otherwise.
            </returns>
        </member>
        <member name="M:Json.Path.IFilterExpression.BuildString(System.Text.StringBuilder)">
            <summary>
            Builds a string using a string builder.
            </summary>
            <param name="builder">The string builder.</param>
        </member>
        <member name="T:Json.Path.IndexSelector">
            <summary>
            Represents an index selector.
            </summary>
        </member>
        <member name="P:Json.Path.IndexSelector.Index">
            <summary>
            Gets the index.
            </summary>
        </member>
        <member name="M:Json.Path.IndexSelector.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:Json.Path.IndexSelector.Evaluate(Json.Path.Node,System.Text.Json.Nodes.JsonNode)">
             <summary>
             Evaluates the selector.
             </summary>
             <param name="match">The node to evaluate.</param>
             <param name="rootNode">The root node (typically used by filter selectors, e.g. `$[?@foo &lt; $.bar]`)</param>
             <returns>
             A collection of nodes.
            
             Semantically, this is a nodelist, but leaving as IEnumerable&lt;Node&gt; allows for deferred execution.
             </returns>
        </member>
        <member name="M:Json.Path.IndexSelector.BuildString(System.Text.StringBuilder)">
            <summary>
            Builds a string using a string builder.
            </summary>
            <param name="builder">The string builder.</param>
        </member>
        <member name="T:Json.Path.IPathFunctionDefinition">
            <summary>
            Defines properties and methods required for an expression function.
            </summary>
            <remarks>Functions must be registered with one of the static `Register()`
            methods defined on <see cref="T:Json.Path.FunctionRepository"/></remarks>
        </member>
        <member name="P:Json.Path.IPathFunctionDefinition.Name">
            <summary>
            Gets the function name.
            </summary>
        </member>
        <member name="T:Json.Path.ValueFunctionDefinition">
            <summary>
            Base class for defining an expression function which returns `ValueType`.
            </summary>
        </member>
        <member name="P:Json.Path.ValueFunctionDefinition.Nothing">
            <summary>
            Represents the absence of a JSON value and is distinct from any JSON value, including null.
            </summary>
        </member>
        <member name="P:Json.Path.ValueFunctionDefinition.Name">
            <summary>
            Gets the function name.
            </summary>
        </member>
        <member name="T:Json.Path.LogicalFunctionDefinition">
            <summary>
            Base class for defining an expression function which returns `LogicalType`.
            </summary>
        </member>
        <member name="P:Json.Path.LogicalFunctionDefinition.Name">
            <summary>
            Gets the function name.
            </summary>
        </member>
        <member name="T:Json.Path.NodelistFunctionDefinition">
            <summary>
            Base class for defining an expression function which returns `NodesType`.
            </summary>
        </member>
        <member name="P:Json.Path.NodelistFunctionDefinition.Name">
            <summary>
            Gets the function name.
            </summary>
        </member>
        <member name="T:Json.Path.ISelector">
            <summary>
            Defines a path segment selector.
            </summary>
        </member>
        <member name="M:Json.Path.ISelector.Evaluate(Json.Path.Node,System.Text.Json.Nodes.JsonNode)">
             <summary>
             Evaluates the selector.
             </summary>
             <param name="match">The node to evaluate.</param>
             <param name="rootNode">The root node (typically used by filter selectors, e.g. `$[?@foo &lt; $.bar]`)</param>
             <returns>
             A collection of nodes.
            
             Semantically, this is a nodelist, but leaving as IEnumerable&lt;Node&gt; allows for deferred execution.
             </returns>
        </member>
        <member name="M:Json.Path.ISelector.BuildString(System.Text.StringBuilder)">
            <summary>
            Builds a string using a string builder.
            </summary>
            <param name="builder">The string builder.</param>
        </member>
        <member name="T:Json.Path.JsonNodeExtensions">
            <summary>
            Useful extensions for <see cref="T:System.Text.Json.Nodes.JsonNode"/>.
            </summary>
        </member>
        <member name="M:Json.Path.JsonNodeExtensions.TryGetValue``1(System.Text.Json.Nodes.JsonNode,``0@)">
            <summary>
            Extends <see cref="M:System.Text.Json.Nodes.JsonValue.TryGetValue``1(``0@)"/> to the <see cref="T:System.Text.Json.Nodes.JsonNode"/> base class.
            </summary>
            <typeparam name="T">The type of value desired.</typeparam>
            <param name="node">The node that may contain the value.</param>
            <param name="value">The value if successful; null otherwise.</param>
            <returns>True if successful; false otherwise.</returns>
        </member>
        <member name="M:Json.Path.JsonNodeExtensions.TryGetSingleValue(System.Text.Json.Nodes.JsonNode)">
             <summary>
             Ensures a <see cref="T:System.Text.Json.Nodes.JsonNode"/> only represents a single value.
             </summary>
             <param name="node"></param>
             <returns>
             Within the context of this library, a <see cref="T:Json.Path.NodeList"/>
             may be stored inside a <see cref="T:System.Text.Json.Nodes.JsonNode"/>.  Some operations, such as
             expression addition, require that a single value is provided.
            
             This method checks to see if the underlying value of a `JsonNode`
             is a `NodeList`.  If not, it simply returns the JsonNode.  If the underlying
             value is a `NodeList` _and_ the it only contains a single value, it
             returns that value.  Otherwise, it returns null.
             </returns>
             <remarks>
             Though a bit complex, this method can be very important for functions
             that require single values as inputs rather than nodelists since function
             composition is possible (e.g. `min(max(@,0),10)`) and functions return nodelists.
             </remarks>
        </member>
        <member name="M:Json.Path.JsonNodeExtensions.TryGetSingleValue(Json.Path.NodeList)">
             <summary>
             Ensures a <see cref="T:Json.Path.NodeList"/> only represents a single value.
             </summary>
             <param name="nodeList"></param>
             <returns>
             Within the context of this library, a <see cref="T:Json.Path.NodeList"/>
             may be stored inside a <see cref="T:System.Text.Json.Nodes.JsonNode"/>.  Some operations, such as
             expression addition, require that a single value is provided.
            
             This method checks to see if the underlying value of a `JsonNode`
             is a `NodeList`.  If not, it simply returns the JsonNode.  If the underlying
             value is a `NodeList` _and_ the it only contains a single value, it
             returns that value.  Otherwise, it returns null.
             </returns>
             <remarks>
             Though a bit complex, this method can be very important for functions
             that require single values as inputs rather than nodelists since function
             composition is possible (e.g. `min(max(@,0),10)`) and functions return nodelists.
             </remarks>
        </member>
        <member name="T:Json.Path.JsonPath">
            <summary>
            Represents a JSON Path.
            </summary>
        </member>
        <member name="P:Json.Path.JsonPath.Root">
            <summary>
            Gets a JSON Path with only a global root and no selectors, namely `$`.
            </summary>
        </member>
        <member name="P:Json.Path.JsonPath.Scope">
            <summary>
            Gets the scope of the path.
            </summary>
        </member>
        <member name="P:Json.Path.JsonPath.IsSingular">
             <summary>
             Gets whether the path is a singular path.  That is, it can only return a nodelist
             containing at most a single value.
             </summary>
             <remarks>
             A singular path can only contain segments which must meet all of the following
             conditions:
            
             - is not a recursive descent (`..`)
             - contains a single selector
             - that selector is either an index selector or a name selector
            
             For example, `$['foo'][1]` is a singular path.  Shorthand syntax (e.g. `$.foo[1]`)
             is also allowed.
             </remarks>
        </member>
        <member name="P:Json.Path.JsonPath.Segments">
            <summary>
            Gets the segments of the path.
            </summary>
        </member>
        <member name="M:Json.Path.JsonPath.Parse(System.String,Json.Path.PathParsingOptions)">
            <summary>
            Parses a <see cref="T:Json.Path.JsonPath"/> from a string.
            </summary>
            <param name="source">The source string.</param>
            <param name="options">(optional) The parsing options.</param>
            <returns>The parsed path.</returns>
            <exception cref="T:Json.Path.PathParseException">Thrown if a syntax error occurred.</exception>
        </member>
        <member name="M:Json.Path.JsonPath.TryParse(System.String,Json.Path.JsonPath@,Json.Path.PathParsingOptions)">
            <summary>
            Parses a <see cref="T:Json.Path.JsonPath"/> from a string.
            </summary>
            <param name="source">The source string.</param>
            <param name="options">(optional) The parsing options.</param>
            <param name="path">The parsed path, if successful; otherwise null.</param>
            <returns>True if successful; otherwise false.</returns>
        </member>
        <member name="M:Json.Path.JsonPath.Evaluate(System.Text.Json.Nodes.JsonNode,Json.Path.PathEvaluationOptions)">
            <summary>
            Evaluates the path against a JSON instance.
            </summary>
            <param name="root">The root of the JSON instance.</param>
            <param name="options">Evaluation options.</param>
            <returns>The results of the evaluation.</returns>
        </member>
        <member name="M:Json.Path.JsonPath.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:Json.Path.JsonPath.BuildString(System.Text.StringBuilder)">
            <summary>
            Builds a string representation of the path using a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">The string builder.</param>
        </member>
        <member name="T:Json.Path.JsonPathConverter">
            <summary>
            JSON converter for <see cref="T:Json.Path.JsonPath"/>.
            </summary>
        </member>
        <member name="M:Json.Path.JsonPathConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <summary>Reads and converts the JSON to type <see cref="T:Json.Path.JsonPath"/>.</summary>
            <param name="reader">The reader.</param>
            <param name="typeToConvert">The type to convert.</param>
            <param name="options">An object that specifies serialization options to use.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:Json.Path.JsonPathConverter.Write(System.Text.Json.Utf8JsonWriter,Json.Path.JsonPath,System.Text.Json.JsonSerializerOptions)">
            <summary>Writes a specified value as JSON.</summary>
            <param name="writer">The writer to write to.</param>
            <param name="value">The value to convert to JSON.</param>
            <param name="options">An object that specifies serialization options to use.</param>
        </member>
        <member name="T:Json.Path.JsonPathExtensions">
            <summary>
            Provides extended functionality for <see cref="T:Json.Path.JsonPath"/>.
            </summary>
        </member>
        <member name="M:Json.Path.JsonPathExtensions.AsJsonPointer(Json.Path.JsonPath)">
            <summary>
            Renders a Singular Path as a JSON Pointer.
            </summary>
            <param name="path">A JSON Path which is a Singular Path.</param>
            <returns>A string containing a JSON Pointer.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the path is not singular.</exception>
        </member>
        <member name="T:Json.Path.JsonPathTypeConverter">
            <summary>
            <see cref="T:System.ComponentModel.TypeConverter"/> for <see cref="T:Json.Path.JsonPath"/>.
            </summary>
        </member>
        <member name="F:Json.Path.JsonPathTypeConverter._standardValues">
            <summary>
            The standard values used by this converter.
            </summary>
            <remarks>
              This field is initialized using a so-called poor man's lazy in <see cref="M:Json.Path.JsonPathTypeConverter.GetStandardValues(System.ComponentModel.ITypeDescriptorContext)"/>.
            </remarks>
        </member>
        <member name="M:Json.Path.JsonPathTypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Json.Path.JsonPathTypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Json.Path.JsonPathTypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Json.Path.JsonPathTypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Json.Path.JsonPathTypeConverter.GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext)">
            <inheritdoc/>
        </member>
        <member name="M:Json.Path.JsonPathTypeConverter.GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext)">
            <inheritdoc/>
        </member>
        <member name="M:Json.Path.JsonPathTypeConverter.GetStandardValues(System.ComponentModel.ITypeDescriptorContext)">
            <inheritdoc/>
        </member>
        <member name="M:Json.Path.JsonPathTypeConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Json.Path.LengthFunction">
            <summary>
            Implements the `length()` function to get:
            - the length of a string
            - the count of values in an array
            - the count of values in an object
            </summary>
        </member>
        <member name="P:Json.Path.LengthFunction.Name">
            <summary>
            Gets the function name.
            </summary>
        </member>
        <member name="M:Json.Path.LengthFunction.Evaluate(System.Text.Json.Nodes.JsonNode)">
            <summary>
            Evaluates the function.
            </summary>
            <param name="value">An object, array, or string</param>
            <returns>If an object or array, the number of items it contains; if a string, the length.</returns>
        </member>
        <member name="T:Json.Path.MatchFunction">
            <summary>
            Implements the `match()` function which determines if a string exactly matches a regular
            expression (using implicit anchoring).
            </summary>
        </member>
        <member name="P:Json.Path.MatchFunction.Name">
            <summary>
            Gets the function name.
            </summary>
        </member>
        <member name="M:Json.Path.MatchFunction.Evaluate(System.Text.Json.Nodes.JsonNode,System.Text.Json.Nodes.JsonNode)">
            <summary>
            Evaluates the function.
            </summary>
            <param name="value">The value to test.</param>
            <param name="pattern">The iregexp pattern to test against.</param>
            <returns>true if the whole string is a match for the pattern; false otherwise.</returns>
        </member>
        <member name="T:Json.Path.NameSelector">
            <summary>
            Represents a name selector.
            </summary>
        </member>
        <member name="P:Json.Path.NameSelector.Name">
            <summary>
            Gets the name.
            </summary>
        </member>
        <member name="M:Json.Path.NameSelector.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:Json.Path.NameSelector.Evaluate(Json.Path.Node,System.Text.Json.Nodes.JsonNode)">
             <summary>
             Evaluates the selector.
             </summary>
             <param name="match">The node to evaluate.</param>
             <param name="rootNode">The root node (typically used by filter selectors, e.g. `$[?@foo &lt; $.bar]`)</param>
             <returns>
             A collection of nodes.
            
             Semantically, this is a nodelist, but leaving as IEnumerable&lt;Node&gt; allows for deferred execution.
             </returns>
        </member>
        <member name="M:Json.Path.NameSelector.BuildString(System.Text.StringBuilder)">
            <summary>
            Builds a string using a string builder.
            </summary>
            <param name="builder">The string builder.</param>
        </member>
        <member name="T:Json.Path.Node">
            <summary>
            Represents a single match.
            </summary>
        </member>
        <member name="P:Json.Path.Node.Value">
            <summary>
            The value at the matching location.
            </summary>
        </member>
        <member name="P:Json.Path.Node.Location">
            <summary>
            The location where the value was found.
            </summary>
        </member>
        <member name="T:Json.Path.NodeList">
            <summary>
            A collection of nodes, generally resulting from an operation or query.
            </summary>
        </member>
        <member name="F:Json.Path.NodeList.Empty">
            <summary>
            An empty nodelist.
            </summary>
        </member>
        <member name="P:Json.Path.NodeList.Count">
            <summary>Gets the number of elements in the collection.</summary>
            <returns>The number of elements in the collection.</returns>
        </member>
        <member name="P:Json.Path.NodeList.Item(System.Int32)">
            <summary>Gets the element at the specified index in the read-only list.</summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index in the read-only list.</returns>
        </member>
        <member name="M:Json.Path.NodeList.#ctor(System.Collections.Generic.IEnumerable{Json.Path.Node})">
            <summary>
            Creates a new nodelist.
            </summary>
            <param name="nodes">The nodes.</param>
        </member>
        <member name="M:Json.Path.NodeList.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="T:Json.Path.PathEvaluationOptions">
            <summary>
            Provides a number of options to be used during evaluation.
            </summary>
            <remarks>
            Currently that number is zero.
            </remarks>
        </member>
        <member name="T:Json.Path.PathParseException">
            <summary>
            Thrown when an error occurs attempting to parse a JSON Path.
            </summary>
        </member>
        <member name="P:Json.Path.PathParseException.Index">
            <summary>
            The index at which the error occurred.
            </summary>
        </member>
        <member name="T:Json.Path.PathParsingOptions">
            <summary>
            Defines a set of configuration options to control parsing behavior.
            </summary>
        </member>
        <member name="P:Json.Path.PathParsingOptions.AllowMathOperations">
            <summary>
            Gets or sets whether mathematical operators are allowed.
            </summary>
            <remarks>
            These operators are an extension of the specification, so they
            are disallowed by default.
            </remarks>
        </member>
        <member name="P:Json.Path.PathParsingOptions.AllowRelativePathStart">
            <summary>
            Gets or sets whether a JSON Path can start with the `@` symbol
            instead of `$`.
            </summary>
        </member>
        <member name="P:Json.Path.PathParsingOptions.AllowJsonConstructs">
            <summary>
            Gets or sets whether JSON objects and arrays (double-quotes only)
            are permitted in expression syntax.
            </summary>
            <remarks>
            Per the specification, only numbers, strings, `null`, `true`,
            and `false` are permitted.
            </remarks>
        </member>
        <member name="P:Json.Path.PathParsingOptions.TolerateExtraWhitespace">
            <summary>
            Gets or sets whether the JSON Path can contain whitespace in places
            the spec says it shouldn't, e.g. between a function name and the
            opening parenthesis.
            </summary>
            <remarks>
            Per the specification, leading or trailing whitespace is also
            forbidden.  Enabling this option permits this.
            </remarks>
        </member>
        <member name="P:Json.Path.PathParsingOptions.AllowInOperator">
             <summary>
             Gets or sets whether the `in` operator is allowed.
             </summary>
             <remarks>
             These operators are an extension of the specification, so they
             are disallowed by default.
            
             May also require that <see cref="P:Json.Path.PathParsingOptions.AllowJsonConstructs"/> be set to
             `true` so that array and object literals are also permitted.
             </remarks>
        </member>
        <member name="T:Json.Path.PathResult">
            <summary>
            The results of a JSON Path evaluation against a JSON instance.
            </summary>
        </member>
        <member name="P:Json.Path.PathResult.Matches">
            <summary>
            The list of matches.
            </summary>
        </member>
        <member name="P:Json.Path.PathResult.Error">
            <summary>
            An error, if any, that occurred during evaluation.
            </summary>
        </member>
        <member name="T:Json.Path.PathScope">
            <summary>
            Indicates the scope of a path.
            </summary>
        </member>
        <member name="F:Json.Path.PathScope.Global">
            <summary>
            The scope is the entire JSON document.  These paths start with `$`.
            </summary>
        </member>
        <member name="F:Json.Path.PathScope.Local">
            <summary>
            The scope is the local JSON value.  These paths start with `@`.
            </summary>
        </member>
        <member name="T:Json.Path.PathSegment">
            <summary>
            Represents a single path segment, generally indicated in the path by square brackets `[]`.
            </summary>
        </member>
        <member name="P:Json.Path.PathSegment.Selectors">
            <summary>
            Gets the collection of selectors present in the path.
            </summary>
        </member>
        <member name="P:Json.Path.PathSegment.IsRecursive">
            <summary>
            Indicates whether the segment is evaluated as a recursive descent operation.
            </summary>
        </member>
        <member name="P:Json.Path.PathSegment.IsShorthand">
            <summary>
            Indicates whether the segment is represented in its shorthand form (e.g. `.foo` instead of `['foo']`).
            </summary>
        </member>
        <member name="M:Json.Path.PathSegment.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:Json.Path.PathSegment.BuildString(System.Text.StringBuilder)">
            <summary>
            Builds a string representation using a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">A string builder.</param>
        </member>
        <member name="T:Json.Path.SearchFunction">
            <summary>
            Implements the `match()` function which determines if any substring within
            a string matches a regular expression.
            </summary>
        </member>
        <member name="P:Json.Path.SearchFunction.Name">
            <summary>
            Gets the function name.
            </summary>
        </member>
        <member name="M:Json.Path.SearchFunction.Evaluate(System.Text.Json.Nodes.JsonNode,System.Text.Json.Nodes.JsonNode)">
            <summary>
            Evaluates the function.
            </summary>
            <param name="value">The value to test.</param>
            <param name="pattern">The iregexp pattern to test against.</param>
            <returns>true if the string contains a match for the pattern; false otherwise.</returns>
        </member>
        <member name="T:Json.Path.SliceSelector">
            <summary>
            Represents a slice selector in the form `start : end : step`.
            </summary>
        </member>
        <member name="P:Json.Path.SliceSelector.Start">
            <summary>
            Gets the start.
            </summary>
        </member>
        <member name="P:Json.Path.SliceSelector.End">
            <summary>
            Gets the end.
            </summary>
        </member>
        <member name="P:Json.Path.SliceSelector.Step">
            <summary>
            Gets the step.
            </summary>
        </member>
        <member name="M:Json.Path.SliceSelector.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:Json.Path.SliceSelector.Evaluate(Json.Path.Node,System.Text.Json.Nodes.JsonNode)">
             <summary>
             Evaluates the selector.
             </summary>
             <param name="match">The node to evaluate.</param>
             <param name="rootNode">The root node (typically used by filter selectors, e.g. `$[?@foo &lt; $.bar]`)</param>
             <returns>
             A collection of nodes.
            
             Semantically, this is a nodelist, but leaving as IEnumerable&lt;Node&gt; allows for deferred execution.
             </returns>
        </member>
        <member name="M:Json.Path.SliceSelector.BuildString(System.Text.StringBuilder)">
            <summary>
            Builds a string using a string builder.
            </summary>
            <param name="builder">The string builder.</param>
        </member>
        <member name="T:Json.Path.ValueFunction">
            <summary>
            Implements the `value()` function which extracts a single value from a nodelist.
            </summary>
        </member>
        <member name="P:Json.Path.ValueFunction.Name">
            <summary>
            Gets the function name.
            </summary>
        </member>
        <member name="M:Json.Path.ValueFunction.Evaluate(Json.Path.NodeList)">
            <summary>
            Evaluates the function.
            </summary>
            <param name="nodeList">A nodelist.</param>
            <returns>If the nodelist contains a single node, that node's value; otherwise null.</returns>
        </member>
        <member name="T:Json.Path.WildcardSelector">
            <summary>
            Represents a wildcard selector, `[*]` or `.*`.
            </summary>
        </member>
        <member name="M:Json.Path.WildcardSelector.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="M:Json.Path.WildcardSelector.Evaluate(Json.Path.Node,System.Text.Json.Nodes.JsonNode)">
             <summary>
             Evaluates the selector.
             </summary>
             <param name="match">The node to evaluate.</param>
             <param name="rootNode">The root node (typically used by filter selectors, e.g. `$[?@foo &lt; $.bar]`)</param>
             <returns>
             A collection of nodes.
            
             Semantically, this is a nodelist, but leaving as IEnumerable&lt;Node&gt; allows for deferred execution.
             </returns>
        </member>
        <member name="M:Json.Path.WildcardSelector.BuildString(System.Text.StringBuilder)">
            <summary>
            Builds a string using a string builder.
            </summary>
            <param name="builder">The string builder.</param>
        </member>
    </members>
</doc>
